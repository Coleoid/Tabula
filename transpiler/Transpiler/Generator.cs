using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Tabula
{
    public class ImplementationInfo
    {
        public string ClassName { get; set; }
        public string MethodName { get; set; }

        //  in-scope instance of the variable, which should
        public string ObjectName { get; set; }
    }

    public class MethodDetails
    {
        string Name { get; set; }
        string SearchKey { get; set; }
        List<string> Args { get; set; }
    }

    public class WorkflowDetails
    {
        public Dictionary<string, MethodDetails> Methods { get; set; }
    }

    public class Generator
    {
        private string GeneratorVersion = "0.1";

        public string GeneratedClassName { get; set; }

        public CST.Scenario Scenario { get; set; }

        public StringBuilder Builder { get; set; }

        public string InputFilePath { get; set; }


        //API: Find implementation object name from a search key
        //API: Find method name from a search key
        //API: Restrict finding to the objects in (compile-time) scope

        public Dictionary<string, List<KeyValuePair<string, ImplementationInfo>>> WorkflowImplementations { get; set; }

        public Generator()
        {
            WorkflowImplementations = new Dictionary<string, List<KeyValuePair<string, ImplementationInfo>>>();
            WorkflowsInScope = new List<string>();
        }

        public void Generate(CST.Scenario scenario, string inputFilePath, StringBuilder builder)
        {
            Scenario = scenario;
            Builder = builder;
            InputFilePath = inputFilePath;

            BuildHeader();
            BuildNamespaceOpen();
            BuildClassOpen();
            BuildConstructor();
            BuildClassBody();
            BuildClassClose();
            BuildNamespaceClose();
        }

        public void BuildHeader()
        {
            Builder.AppendLine($"//  This file was generated by TabulaClassGenerator version {GeneratorVersion}.");
            Builder.AppendLine($"//  To change this file, change the Tabula scenario at {InputFilePath}.");
            Builder.AppendLine($"//  Version {GeneratorVersion} only generates this rudimentary paste.  You have been warned.");
            Builder.AppendLine("using System;");
            Builder.AppendLine("using System.Collections.Generic;");
            Builder.AppendLine("using Acadis.Constants.Accounting;");
            Builder.AppendLine("using Acadis.Constants.Admin;");
            Builder.AppendLine("using Acadis.SystemUtilities;");
            Builder.AppendLine();
        }

        public void BuildNamespaceOpen()
        {
            Builder.AppendLine("namespace Tabula");
            Builder.AppendLine("{");
        }


        public void BuildClassOpen()
        {
            GeneratedClassName = ClassNameFromInputFilePath();
            Builder.AppendLine($"    public class {GeneratedClassName}  //  {Scenario.Label}");
            Builder.AppendLine("        : GeneratedScenarioBase, IGeneratedScenario");
            Builder.AppendLine("    {");
        }

        public string ClassNameFromInputFilePath()
        {
            //  remove everything before the last backslash
            int lastBackslash = InputFilePath.LastIndexOf("\\");
            if (lastBackslash != -1)
                InputFilePath = InputFilePath.Substring(lastBackslash + 1);

            //  remove everything after the last dot
            int lastDot = InputFilePath.LastIndexOf('.');
            if (lastDot != -1)
                InputFilePath = InputFilePath.Remove(lastDot);

            return InputFilePath.Replace(' ', '_').Replace('.', '_') + "_generated";

        }


        public void BuildClassBody()
        {
            var executeMethodBody = new IndentingStringBuilder(12);  // namespace + class + inside method
            var sectionsBody = new IndentingStringBuilder(8);  // namespace + class

            foreach (var section in Scenario.Sections)
            {

                if (section is CST.Paragraph para)
                {
                    WorkflowsInScope = new List<string>();

                    //TODO:  set Paragraph.MethodName (at end of paragraph parse?)
                    sectionsBody.AppendLine(para.MethodName + "()");
                    sectionsBody.AppendLine("{");
                    sectionsBody.Indent();
                    foreach (var action in para.Actions)
                    {
                        BuildAction(action);
                    }
                    sectionsBody.Dedent();
                    sectionsBody.AppendLine("}");

                    //TODO:  Handle called, uncalled, and final paragraph cases
                    executeMethodBody.AppendLine(para.MethodName + "();");
                }

                if (section is CST.Table table)
                {
                    //generate table (table generator method, technically)
                    //get staged paragraph name
                    //AppendLine RunParaOverTable( {paraName}, {tableName} );
                }
            }

            //TODO:  write final paragraph call unless a table has already run over it.


            //TODO:  Append the built text into the main Builder
        }

        public List<string> WorkflowsInScope { get; set; }

        public void BuildAction(CST.Action action)
        {
            if (action is CST.CommandUse useCommand)
            {
                foreach (var newWorkflowName in useCommand.Workflows)
                {
                    if (!WorkflowsInScope.Contains(newWorkflowName))
                    {
                        WorkflowsInScope.Add(newWorkflowName);
                    }
                }
            }
            else if (action is CST.Step step)
            {
                BuildStep(step);
            }
            else if (action is CST.CommandSet setCommand)
            {
                throw new NotImplementedException("TODO: Stash value in runtime context");
            }
            else if (action is CST.CommandAlias aliasCommand)
            {
                throw new NotImplementedException("TODO: Add the alias to the implementations");
            }
            else
                throw new NotImplementedException($"So {action.GetType().FullName} is an action now, huh?  Tell me what to do about that, please.");
        }

        public void BuildStep(CST.Step step)
        {
            string searchName = step.GetCanonicalMethodName();
            var implementation = FindImplementation(searchName);

            var lineNumber = step.Symbols[0].LineNumber;
            var sourceLocation = $"\"{InputFilePath}:{lineNumber}\"";

            if (implementation == null)
            {
                var stepText = "\"" + step.GetReadableString() + "\"";
                var unfound = $"            Unfound(      {stepText}, {sourceLocation});";
                Builder.AppendLine(unfound);
            }
            else
            {
                var call = ComposeCall(step, implementation);
                var quotedCall = "@\"" + call.Replace("\"", "\"\"") + "\"";
                Builder.AppendLine($"           Do(() =>       {call}. {sourceLocation}, {quotedCall});");
            }
        }

        public string ComposeCall(CST.Step step, ImplementationInfo implementation)
        {
            string argsString = "";
            string delim = "";
            foreach (var sym in step.Symbols)
            {
                //TODO:  Keep watch on string representations, eventual rework
                if (sym.Type != TokenType.Word)
                {
                    if (sym.Type == TokenType.String)
                    {
                        argsString += delim + "\"" + sym.Text + "\"";
                    }
                    else if (sym.Type == TokenType.Date)
                    {
                        argsString += delim + "\"" + sym.Text + "\".To<DateTime>()";
                    }
                    else
                    {
                        argsString += delim + sym.Text;
                    }

                    delim = ", ";
                }
            }

            var workflowName = implementation.ObjectName;
            var methodName = implementation.MethodName;
            var call = $"{workflowName}.{methodName}({argsString})";

            return call;
        }


        public ImplementationInfo FindImplementation(string lookupName)
        {
            foreach(var workflowName in WorkflowsInScope)
            {
                var methods = WorkflowImplementations[workflowName];
                var found = methods.LastOrDefault(i => i.Key == lookupName);
                if (found.Key == lookupName) return found.Value;
            }

            return null;
        }

        public List<string> GetNeededWorkflows()
        {
            List<string> nws = Scenario.NeededWorkflows;
            nws.Sort();
            var unws = nws.Distinct(StringComparer.CurrentCultureIgnoreCase).ToList();

            return unws;
        }

        //public void AddWorkflow(string workflowName)
        //{
        //    NeededWorkflows.Add(workflowName);
        //}

        public void BuildDeclarations()
        {
            foreach (var workflow in GetNeededWorkflows())
            {
                var varName = GetNameOfWorkflowInstance(workflow);
                Builder.AppendFormat("public {0} {1};{2}", workflow, varName, Environment.NewLine);
            }
        }

        //  Since workflow instantiation happens in each paragraph, this is (for now) a stub.
        public void BuildConstructor()
        {
            Builder.Append("        public ");
            Builder.Append(GeneratedClassName);
            Builder.AppendLine("()");
            Builder.AppendLine("            : base()");
            Builder.AppendLine("        {");
            Builder.AppendLine("        }");
        }

        public void BuildClassClose()
        {
            Builder.AppendLine("    }");
        }

        public void BuildNamespaceClose()
        {
            Builder.AppendLine("}");
        }

        public string GetNameOfWorkflowInstance(string workflowName)
        {
            var lastDot = workflowName.LastIndexOf('.');
            return workflowName.Substring(lastDot + 1).Replace("Workflow", "");
        }

        public void AddImplementation(ImplementationInfo ii)
        {
            var impls = WorkflowImplementations.ContainsKey(ii.ObjectName)
                ? WorkflowImplementations[ii.ObjectName]
                : new List<KeyValuePair<string, ImplementationInfo>>();

            var searchName = ii.MethodName;
            impls.Add(new KeyValuePair<string, ImplementationInfo>(SearchName(ii.MethodName), ii));
            WorkflowImplementations[ii.ObjectName] = impls;
        }

        public string SearchName(string methodName)
        {
            return methodName.Replace("_", "").ToLower();
        }

        //TODO:  Figure out point of entry for testing/implementing proper workflow info stashing
    //    public string InstanceNameFromClassName(string className)
    //    {
    //        foreach (var key in WorkflowImplementations.Keys)
    //        {
    //            var impl = WorkflowImplementations[key];
    //            if (impl == className)
    //                return key;
    //        }
    //    }
    }
}
