using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Tabula
{
    public class Generator
    {
        private string GeneratorVersion = "0.1";

        public CST.Scenario Scenario { get; set; }
        public StringBuilder Builder { get; set; }

        public void Generate(CST.Scenario scenario, string inputFilePath, StringBuilder builder)
        {
            Scenario = scenario;
            Builder = builder;

            BuildHeader(inputFilePath);
            OpenNamespace();
            OpenClass(inputFilePath);
            BuildClassBody();
            CloseClass();
            CloseNamespace();
        }

        public void BuildHeader(string inputFilePath)
        {
            Builder.AppendLine($"//  This file was generated by TabulaClassGenerator version {GeneratorVersion}.");
            Builder.AppendLine($"//  To change this file, change the Tabula scenario at {inputFilePath}.");
            Builder.AppendLine($"//  Version {GeneratorVersion} only generates this rudimentary paste.  You have been warned.");
            Builder.AppendLine("using System;");
            Builder.AppendLine("using System.Collections.Generic;");
            Builder.AppendLine("using Acadis.Constants.Accounting;");
            Builder.AppendLine("using Acadis.Constants.Admin;");
            Builder.AppendLine("using Acadis.SystemUtilities;");
            Builder.AppendLine();
        }

        public void OpenNamespace()
        {
            Builder.AppendLine("namespace Tabula");
            Builder.AppendLine("{");
        }


        public void OpenClass(string inputFilePath)
        {
            ClassName = ClassNameFromInputFilePath(inputFilePath);
            Builder.AppendLine($"    public class {ClassName}  //  {Scenario.Label}");
            Builder.AppendLine("        : GeneratedScenarioBase, IGeneratedScenario");
            Builder.AppendLine("    {");
        }

        public string ClassName { get; set; }
        public string ClassNameFromInputFilePath(string inputFilePath)
        {
            //  remove everything before the last backslash
            int lastBackslash = inputFilePath.LastIndexOf("\\");
            if (lastBackslash != -1)
                inputFilePath = inputFilePath.Substring(lastBackslash + 1);

            //  remove everything after the last dot
            int lastDot = inputFilePath.LastIndexOf('.');
            if (lastDot != -1)
                inputFilePath = inputFilePath.Remove(lastDot);

            return inputFilePath.Replace(' ', '_').Replace('.', '_') + "_generated";

        }

        public class IndentingSBuilder
        {
            private bool StartOfLine = true;
            private StringBuilder _builder;
            public StringBuilder Builder
            {
                get
                {
                    if (_builder == null)
                        _builder = new StringBuilder();
                    return _builder;
                }
                internal set { _builder = value; }
            }

            internal int indentLevel = 0;

            public void Indent()
            {
                indentLevel += 4;
                _indentation = new string(' ', indentLevel);
            }
            public void Dedent()
            {
                if (indentLevel <= 0) throw new Exception("Tried to dedent past zero.");
                indentLevel -= 4;
                _indentation = new string(' ', indentLevel);
            }

            private string _indentation = string.Empty;
            public string Indentation
            {
                get { return _indentation; }
            }

            private void IndentAtStartOfLine()
            {
                if (!StartOfLine) return;

                Builder.Append(Indentation);
                StartOfLine = false;
            }

            public void Append(string input)
            {
                IndentAtStartOfLine();
                Builder.Append(input);
            }

            public void AppendLine(string input)
            {
                IndentAtStartOfLine();
                Builder.AppendLine(input);
                StartOfLine = true;
            }

            public IndentingSBuilder(int startingIndentLevel)
            {
                indentLevel = startingIndentLevel;
            }
        }

        public void BuildClassBody()
        {
            var executeMethodBody = new IndentingSBuilder(12);  // namespace + class + inside method
            var sectionsBody = new IndentingSBuilder(8);  // namespace + class

            foreach (var section in Scenario.Sections)
            {

                var para = section as CST.Paragraph;
                if (para != null)
                {
                    //TODO:  set Paragraph.MethodName (at end of paragraph parse?)
                    sectionsBody.AppendLine(para.MethodName + "()");
                    sectionsBody.AppendLine("{");
                    sectionsBody.Indent();
                    foreach (var action in para.Actions)
                    {
                        BuildAction(action);
                    }
                    sectionsBody.Dedent();
                    sectionsBody.AppendLine("}");

                    //TODO:  Handle called, uncalled, and final paragraph cases
                    executeMethodBody.AppendLine(para.MethodName + "();");
                }

                var table = section as CST.Table;
                if (table != null)
                {
                    //generate table (table generator method, technically)
                    //get staged paragraph name
                    //AppendLine RunParaOverTable( {paraName}, {tableName} );
                }
            }

            //TODO:  write final paragraph call unless a table has already run over it.


            //TODO:  Append the built text into the main Builder
        }

        public void BuildAction(CST.Action action)
        {
            //TODO:  method resolution or 'unfound'
            //TODO:  rolling into lambda with text of line included
            string workflowName = "WorkflowTodo";
            string methodName = "MethodTodo";
            List<string> args = new List<string> { "this", "that", "todo" };
            string delim = ", ";
            Builder.AppendLine($"               {workflowName}.{methodName}({string.Join(delim, args)});");
        }

        public List<string> GetNeededWorkflows()
        {
            List<string> nws = Scenario.NeededWorkflows;
            nws.Sort();
            var unws = nws.Distinct(StringComparer.CurrentCultureIgnoreCase).ToList();

            //TODO:
            //  The 'peepEnrollment = new PeopleEnrollmentWorkflow();' lines are placed in
            //   each paragraph (or block) method, as the use command is encountered.
            //  And I need to think out not messing up the state of any workflows which rely
            //   on their state.  Perhaps we manually stash and replace workflow instances?
            //  Or, since I'm doing local initialization, I could switch to local declaration,
            //   also.  Then we need to find a way to know which workflows to pass as arguments,
            //   and do so with all consumers of the block.  More complex.
            //  I don't know where the real use cases will push us, so starting simple (and
            //   working to uncover the forces involved) seems like the plan.

            return unws;
        }

        //public void AddWorkflow(string workflowName)
        //{
        //    NeededWorkflows.Add(workflowName);
        //}

        public void BuildDeclarations()
        {
            foreach (var workflow in GetNeededWorkflows())
            {
                var varName = nameOfWorkflowInstance(workflow);
                Builder.AppendFormat("public {0} {1};{2}", workflow, varName, Environment.NewLine);
            }
        }

        //  Since workflow instantiation happens in each paragraph, this is (for now) a stub.
        public void BuildConstructor(List<string> neededImplementors)
        {
            Builder.Append("        public ");
            Builder.Append(ClassName);
            Builder.AppendLine("()");
            Builder.AppendLine("            : base()");
            Builder.AppendLine("        {");
            Builder.AppendLine("        }");
        }

        public void CloseClass()
        {
            Builder.AppendLine("    }");
        }

        public void CloseNamespace()
        {
            Builder.AppendLine("}");
        }

        public string nameOfWorkflowInstance(string workflowName)
        {
            var lastDot = workflowName.LastIndexOf('.');
            return workflowName.Substring(lastDot + 1).Replace("Workflow", "");
        }
    }
}
